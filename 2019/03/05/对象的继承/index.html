<!Doctype html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <title>对象的继承 | FE 笔记本 🚀</title>
  
    <link rel="icon" href="/images/favico.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/bjb/style/gitalk.css">
  <link rel="stylesheet" href="/bjb/style/style.css">
  <script src="/bjb/js/gitalk.min.js"></script>
</head>
  <body>
    <header class="header">
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/bjb/" class="menu-item-link">首页</a>
        </li>
      
        <li class="menu-item">
          <a href="/bjb/archives" class="menu-item-link">归档</a>
        </li>
      
    </ul>
  </nav>
  <h1 class="pc">FE 笔记本 🚀</h1>
  <h1 class="mobile"><a href="/">FE 笔记本 🚀</a></h1>
  <em>「 学海无涯，没空撩妹！」</em>
</header>
    <main class="main">
      <article class="post">
  <div class="post-title">
    <h2 class="title">对象的继承</h2>
  </div>
  <div class="post-meta">
    <span class="post-time">2019-03-05 14:42:13</span>
    <span class="post-tags">
      
    </span>
    
  </div>
  <div class="post-content">
    <blockquote>
<p><sup>这里是我读<a href="https://wangdoc.com/javascript/" target="_blank" rel="noopener">《阮一峰 JavaScript 教程》</a>做的笔记。</sup></p>
</blockquote>
<p>面向对象编程很重要的一个方面，就是对象的继承，A 对象继承 B 对象，A 对象就能直接用 B 对象的所有属性和方法了，这对于代码的复用非常重要。</p>
<p>大部分面向对象编程的语言，都是通过类 class 实现对象的继承的。传统上 JavaScript 语言的继承不通过 class，而是通过 原型对象 prototype 实现的。ES6 引入了 class 语法。</p>
<h3 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h3><p>JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">'大猫'</span>, <span class="string">'白色'</span>);</span><br><span class="line">cat1.name <span class="comment">// '大猫'</span></span><br><span class="line">cat1.color <span class="comment">// '白色'</span></span><br></pre></td></tr></table></figure>
<p>所有实例对象（这里的 cat1）都会生成这两个属性，即这两个属性会定义在实例对象上面。</p>
<p>通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的都个实例之间，无法共享属性，从而造成对系统资源的浪费。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">  <span class="keyword">this</span>.meow = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'喵'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">'大猫'</span>,<span class="string">'白色'</span>)</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">'二猫'</span>,<span class="string">'黑色'</span>)</span><br><span class="line">cat1.meow === cat2.meow <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p> 每新建一个实例，就会新建一个 meow 方法，这既没必要也浪费资源，因为所有 meow 方法都是同样的行为，完全可以共享。</p>
<p>这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。</p>
<h3 id="prototype-属性的作用"><a href="#prototype-属性的作用" class="headerlink" title="prototype 属性的作用"></a>prototype 属性的作用</h3><p>JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例共享。也就是说，如果属性和方法定义在原型上，那么所有实例就能共享，不仅节省了内存，还体现了实例对象之间的联系。</p>
<p>怎么为对象指定原型？JavaScript 规定，每个函数都有一个 prototype 属性，指向一个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> f.prototype <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure>
<p>函数 f 默认具有 prototype 属性，指向一个对象。</p>
<p>对于普通函数来说，它的 prototype 基本没什么用。但是，对于构造函数来说，生成实例的时候，prototype 会自动成为实例对象的原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.color = <span class="string">'white'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Animal(<span class="string">'大猫'</span>)</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Animal(<span class="string">'二猫'</span>)</span><br><span class="line"></span><br><span class="line">cat1.color <span class="comment">// 'white'</span></span><br><span class="line">cat2.color <span class="comment">// 'white'</span></span><br></pre></td></tr></table></figure>
<p>构造函数 Animal 的 prototype 属性，就是实例对象 cat1 和 cat2 的原型对象。原型对象上添加一个 color 属性，结果，实例对象都共享了该属性。</p>
<p>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就会立刻体现在所有实例对象上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Animal.prototype.color = <span class="string">'yellow'</span></span><br><span class="line">cat1.color <span class="comment">// 'yellow'</span></span><br><span class="line">cat2.color <span class="comment">// 'yellow'</span></span><br></pre></td></tr></table></figure>
<p>如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cat1.color = <span class="string">'black'</span>;</span><br><span class="line"></span><br><span class="line">cat1.color <span class="comment">// 'black'</span></span><br><span class="line">cat2.color <span class="comment">// 'yellow'</span></span><br><span class="line">Animal.prototype.color <span class="comment">// 'yellow';</span></span><br></pre></td></tr></table></figure>
<p>原型对象的作用，就是定义所有实例对象共享的属性和方法。这就是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>JavaScript 规定，所有对象都有自己的原型对象 prototype。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所有它也有自己的原型。因此，就会形成一个原型链 prototype chain：对象的原型，再到原型的原型…</p>
<p>如果一层层地上溯，所有对象的原型最终都可以上溯到 Object.prototype，即 Object 构造函数的 prototype 属性。也就是说所有对象都继承了 Object.prototype 属性。这就是所有对象都有 valueOf 和 toString 方法的原因，因为这是从 Object.prototype 继承的。</p>
<p>那么 Object.prototype 对象有没有它的原型呢？Object.prototype 的原型是 null。null 没有任何属性和方法，也没有自己的原型。因此原型链的尽头是 null。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还找不到，就到原型的原型去找，直到最顶层 Object.prototype，如果还是找不到，则返回 undefined。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做覆盖。</p>
<p>如果一个构造函数的 prototype 属性指向一个数组，那么它的实例对象可以调用数组的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyArray = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">MyArray.prototype = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">MyArray.prototype.constructor = MyArray</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mine = <span class="keyword">new</span> MyArray()</span><br><span class="line">mine.push(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">mine.length <span class="comment">// 3</span></span><br><span class="line">mine instanceOf <span class="built_in">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><p>prototype 对象有个 constructor 属性，默认指向 prototype 对象所在的构造函数。由于 constructor 属性定义在 prototype 对象上，意味着可以被所有实例对象继承。constructor 的作用是，可以得知某个实例对象到底是哪一个构造函数产生的，另一方面，有了 constructor 属性，就可以从一个实例对象新建另一个实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Constr</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Constr();</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> x.constructor();</span><br><span class="line">y instanceOf Constr <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>x 是构造函数 Constr 的实例，可以从 x.constructor 间接调用构造函数。这使得在实例方法中，调用自身构造函数成为可能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Constr.prototype.createCopy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createCopy 方法调用构造函数，新建另一个实例。</p>
<p>constructor 属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改 constructor 属性，防止引用的时候出错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.constructor === Person <span class="comment">// true</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.constructor === Person <span class="comment">// false</span></span><br><span class="line">Person.prototype.constructor === <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>构造函数 Person 的原型对象改掉了，但是么有修改 constructor 属性，导致这个属性不再指向 Person。由于 Person 的新原型是一个普通对象，而普通对象的 constructor 属性指向 Object 构造函数，导致 Person.prototype.constructor 变成 Object</p>
<h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>返回一个布尔值，表示对象是否为某个构造函数的实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle()</span><br><span class="line">v <span class="keyword">instanceof</span> Vehicle; <span class="comment">// true</span></span><br><span class="line">Vehicle.prototype.isPrototypeOf(v) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>instanceof 会检查整个原型链，所以一个实例对象，可能会对多个构造函数返回 true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Date</span> <span class="comment">// true</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>instanceof 是检查右边构造函数的 prototype 属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有 null 对象，这时，instanceof 判断会失真。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">typeof</span> obj <span class="comment">// 'Object'</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>Object.create(null) 返回一个新对象 obj，它的原型是 null。右边的构造函数 Object 的 prototype 属性，不在左边的原型链上，因此 instanceof 就认为 obj 不是 Object 的实例。但是，只要一个对象的原型不是 null，instanceof 运算符的判断就不会失真。</p>
<p>instaceof 运算符的一个用处，是判断值的类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> y = &#123;&#125;</span><br><span class="line">x <span class="keyword">instanceof</span> <span class="built_in">Array</span></span><br><span class="line">y <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br></pre></td></tr></table></figure>
<p>但是不能用与原始类型的值的类型判断</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line">s <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>利用 instanceof 运算符，还可以巧妙地解决，调用构造函数时，忘记加 new 命令的问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fubar</span> (<span class="params">foo, bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Fubar) &#123;</span><br><span class="line">    <span class="keyword">this</span>._foo = foo</span><br><span class="line">    <span class="keyword">this</span>._bar = bar</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Fubar(foo, bar)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数体内判断 this 关键字是否为构造函数 Fubar 实例。如果不是，就表明忘记加 new 命令了</p>
<h3 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h3><p>让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。</p>
<p>第一步是在子类的构造函数中，调用父类的构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  Super.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.prop = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sub 是子类的构造函数，this 是子类的实例。在实例上调用父类的构造函数 Super，就会让子类实例具有父类实例的属性。</p>
<p>第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype)</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.method = <span class="string">'...'</span></span><br></pre></td></tr></table></figure>
<p>Sub.prototype 是子类的原型，要将它赋值为 Object.create(Super.prototype)，而不是直接等于 Super.prototype。否则后面两行对 Sub.prototype 的操作，会连父类的原型 Super.prototype 一起修改掉。</p>
<p>另一种写法是 Sub.prototype 等于一个父类的实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Sub.prototype = <span class="keyword">new</span> Super()</span><br></pre></td></tr></table></figure>
<p>也是有继承的效果，但是子类会具有父类实例的方法。有时，这可能步是我们需要的，所以不推荐这种写法。🤔 啥时候？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Shape.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x += x;</span><br><span class="line">  tihs.y += y;</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">'Shape moved.'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一步 子类继承父类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Shape.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.base = Shape;</span><br><span class="line">  <span class="keyword">this</span>.base(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步 子类继承父类的原型</span></span><br><span class="line">Rectangle.prototype = <span class="built_in">Object</span>.create(Shape.prototype)</span><br><span class="line">Rectangle.prototype.constructor = Rectangle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle()</span><br><span class="line">rect <span class="keyword">instanceof</span> Rectangle <span class="comment">// true</span></span><br><span class="line">rect <span class="keyword">instanceof</span> Shape <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>子类整体继承父类，有时只需要单个方法的继承，这时可以采用下面的写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ClassB.prototype.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ClassA.prototype.print.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类 B 的 print 方法先调用父类 A 的 print 方法，再部署自己的代码。这就等于继承父类 A 的 print 方法。</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>JavaScript 不提供多重继承功能，即不允许使用一个对象同事继承多个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.hello = <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.word = <span class="string">'word'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">S</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  M1.call(<span class="keyword">this</span>)</span><br><span class="line">  M2.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承 M1</span></span><br><span class="line">S.prototype = <span class="built_in">Object</span>.create(M1.prototype)</span><br><span class="line"><span class="comment">// 继承链上加入 M2</span></span><br><span class="line"><span class="built_in">Object</span>.assign(S.prototype, M2.prototype)</span><br><span class="line"></span><br><span class="line">S.prototype.constructor = S</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> S()</span><br><span class="line">s.hello <span class="comment">// 'hello'</span></span><br><span class="line">s.word <span class="comment">// 'word'</span></span><br></pre></td></tr></table></figure>
<p>子类 S 同时继承了父类 M1 和 M2。这种模式又称为 Mixin（混入）</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p><strong>把模块写成一个对象，所有模块成员都放到对象里面</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">  _count: <span class="number">0</span>,</span><br><span class="line">  m1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  m2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这种写法会暴露所有模块成员，内部状态可以被改写，比如外部代码可以直接改变内部计算器的值.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>._count = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p><strong>封装私有变量：构造函数的写法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringBuilder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> buffer = [];</span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    buffer.push(str)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buffer.join(<span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。这意味着，构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。同时，非常耗内存。</p>
<p><strong>封装私有变量：立即执行函数</strong></p>
<p><strong>模块的放大模式</strong></p>
<p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式” augmentation</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params">mod</span>) </span>&#123;</span><br><span class="line">  mod.m3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(module1)</span><br></pre></td></tr></table></figure>
<p>上面的代码为 module1 模块添加了一个新方法 m3，然后返回新的 module1 模块。</p>
<p>在浏览器环境下，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用“宽放大模式” Loose augmentation</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params">mod</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(<span class="built_in">window</span>.module1 || &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>与放大模式相比，宽放大模式就是立即执行函数的参数可以是空对象。</p>
<p><strong>输入全局变量</strong></p>
<p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。</p>
<p>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params">$, YAHOO</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)(jQuery, YAHOO);</span><br></pre></td></tr></table></figure>
<p>立即执行函数还能起到命名空间的作用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$, window, document</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">num</span>) </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dieCarouselDie</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">window</span>.finalCarousel = &#123;</span><br><span class="line">    init: initialize,</span><br><span class="line">    destroy: dieCarouselDie</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(jQuery, <span class="built_in">window</span>, <span class="built_in">document</span>)</span><br></pre></td></tr></table></figure>
<p>最后 finalCarousel 暴露给全局变量，并包含 init 和 destory 两个接口，内部方法 go、handleEvent、initialize、dieCarouselDie 都是无法访问的。</p>

  </div>
  
</article>
    </main>
    <footer>
  <p>&copy; 2019 bjb.dsphoebe.com <wbr> <a href="http://www.miitbeian.gov.cn/">京ICP备15048606号-1</a></p>
</footer>
  </body>
</html>
