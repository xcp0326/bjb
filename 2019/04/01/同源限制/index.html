<!Doctype html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <title>同源限制 | FE NOTEBOOK 🚀</title>
  
    <link rel="icon" href="/images/favico.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/style/gitalk.css">
  <link rel="stylesheet" href="/style/style.css">
  <script src="/js/gitalk.min.js"></script>
</head>
  <body>
    <header class="header">
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">首页</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">归档</a>
        </li>
      
    </ul>
  </nav>
  <h1 class="pc">FE NOTEBOOK 🚀</h1>
  <h1 class="mobile"><a href="/">FE NOTEBOOK 🚀</a></h1>
  <em>「 学海无涯，没空撩妹！」</em>
</header>
    <main class="main">
      <article class="post">
  <div class="post-title">
    <h2 class="title">同源限制</h2>
  </div>
  <div class="post-meta">
    <span class="post-time">2019-04-01 13:32:05</span>
    <span class="post-tags">
      
    </span>
    
  </div>
  <div class="post-content">
    <blockquote>
<p><sup>这里是我读<a href="https://wangdoc.com/javascript/" target="_blank" rel="noopener">《阮一峰 JavaScript 教程》</a>做的笔记。</sup></p>
</blockquote>
<p>浏览器安全的基石 同源策略。</p>
<p>95 年由网景公司引入。最初的含义是指 A 网页设置的 Cookie B 网页不能访问，除非同源。所谓同源就是指：协议相同、域名相同、端口相同。</p>
<p>非同源网页无法读取 DOM、Cookie、Web Storage 和 IndexDB，浏览器拒绝接受非同源地址发送的 AJAX 请求的响应。</p>
<p>非同源的网页，目前允许一个窗口可以接触其他网页的 window 对象的 9 个属性和 4 个方法：<br>    window.closed、window.frames、window.length、window.location、window.opener、<br>    window.parent、window.self、window.top、window.window、<br>    window.blur()、 window.close()、window.focus()、window.postMessage()</p>
<p><strong>如果规避同源限制</strong></p>
<ol>
<li><p>Cookie：只有两个网页是同一个一级域名下的不同二级域名，</p>
<ul>
<li>可以通过在两个网页都设置 document.domain 为一级域名来共享 Cookie。<br>因为浏览器是通过 document.domain 属性来检查是否同源的。因为 document.domain 会把端口号重置为 null，所以如果只设置一个网页的 document.domain，<br>会导致两个网址的端口不同。</li>
<li>可以在服务器设置 Cookie 的时候，设置 domain 为一级域名。<br>显然服务器端修改更方便。</li>
</ul>
</li>
<li><p>iframe 和多窗口通信</p>
<ul>
<li>可以在网页中的 iframe 元素嵌入其他网页。每个 iframe 有自己的网页，有自己的 window 对象。<br>同源情况下，iframe 窗口中的脚本可以获得父窗口和子窗口。同 Cookie 设置一样，如果同一个一级域名下的不同二级域名，就可以通过给两个 iframe<br>设置相同的 document.domain 来实现通信。</li>
<li>完全不同源的话，可以使用<strong>片段标识符</strong>。片段标识符是指 fragment identifier，URL 的 <code>#</code> 号后面的部分。父窗口可以把信息<br>写入子窗口的片段标识符，子窗口则可以通过监听 hashchange 事件获取片段标识符。</li>
<li>完全不同源的话，还可以通过 window.postMessage() 跨文档通信 API Cross-document messaging。<br>不同源网页都可以通过监听 message 事件，监听对方的消息。message 事件的参数事件对象 event，有三个属性<ol>
<li>event.source 发送消息的窗口</li>
<li>event.origin 消息发送的网址</li>
<li>event.data 消息内容</li>
</ol>
</li>
<li><p>window.postMessage 读写 localStorage    </p>
<ul>
<li><p>父窗口发送消息：        </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> win = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'iframe'</span>)[<span class="number">0</span>].contentWindow;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'Jack'</span> &#125;;</span><br><span class="line"><span class="comment">// 存入对象</span></span><br><span class="line">win.postMessage(</span><br><span class="line">    <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">key</span>: <span class="string">'storage'</span>, <span class="attr">method</span>: <span class="string">'set'</span>, <span class="attr">data</span>: obj&#125;),</span><br><span class="line">    <span class="string">'http://bbb.com'</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 读取对象</span></span><br><span class="line">win.postMessage(</span><br><span class="line">    <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">key</span>: <span class="string">'storage'</span>, <span class="attr">method</span>: <span class="string">"get"</span>&#125;),</span><br><span class="line">    <span class="string">"*"</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.origin != <span class="string">'http://aaa.com'</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(e.data).name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子窗口将父窗口发来的消息写入自己的 localStorage：        </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.origin !== <span class="string">'http://bbb.com'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> payload = <span class="built_in">JSON</span>.parse(e.data);</span><br><span class="line">    <span class="keyword">switch</span> (payload.method) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'set'</span>:</span><br><span class="line">            localStorage.setItem(payload.key, <span class="built_in">JSON</span>.stringify(payload.data));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'get'</span>:</span><br><span class="line">            <span class="keyword">var</span> parent = <span class="built_in">window</span>.parent;</span><br><span class="line">            <span class="keyword">var</span> data = localStorage.getItem(payload.key);</span><br><span class="line">            parent.postMesage(data, <span class="string">'http://aaa.com'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'remove'</span>:</span><br><span class="line">            localStorage.removeItem(payload.key);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li>AJAX<ul>
<li>服务器端设置代理，浏览器请求同源服务器，再由后者请求外部服务。</li>
<li>JSONP<br>  网页动态插入一个 <code>&lt;script&gt;</code> 元素，向服务器发送请求。该请求的查询字符串有一个 callback 参数，<br>  用来指定回调函数的名字。服务器收到请求后，会将数据放在这个回调函数里传回来。网页定义了这个回调函数，该函数就会立即调用。</li>
<li>WebSocket 是一种通信协议，使用 ws:// 和 wss:// 作为协议前缀。不实行同源协议，只要服务器支持，就可以通过它进行跨源通信。<br>浏览器发出的 WebSocket 通信协议请求的头信息里面包含字段 Origin，服务器就是根据这个字段胖达是否许可本次通信。</li>
<li>CORS：Cross-Origin Resource Sharing 的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。        </li>
</ul>
</li>
</ol>

  </div>
  
</article>
    </main>
    <footer>
  <p>&copy; 2019 code.dsphoebe.com <wbr> <a href="http://www.miitbeian.gov.cn/">京ICP备15048606号-1</a></p>
</footer>
  </body>
</html>
