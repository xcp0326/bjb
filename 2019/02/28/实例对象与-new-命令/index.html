<!Doctype html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <title>实例对象与 new 命令 | FE NOTEBOOK 🚀</title>
  
    <link rel="icon" href="/images/favico.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/style/gitalk.css">
  <link rel="stylesheet" href="/style/style.css">
  <script src="/js/gitalk.min.js"></script>
</head>
  <body>
    <header class="header">
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">首页</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">归档</a>
        </li>
      
    </ul>
  </nav>
  <h1 class="pc">FE NOTEBOOK 🚀</h1>
  <h1 class="mobile"><a href="/">FE NOTEBOOK 🚀</a></h1>
  <em>「 学海无涯，没空撩妹！」</em>
</header>
    <main class="main">
      <article class="post">
  <div class="post-title">
    <h2 class="title">实例对象与 new 命令</h2>
  </div>
  <div class="post-meta">
    <span class="post-time">2019-02-28 11:34:39</span>
    <span class="post-tags">
      
    </span>
    
  </div>
  <div class="post-content">
    <blockquote>
<p><sup>这里是我读<a href="https://wangdoc.com/javascript/" target="_blank" rel="noopener">《阮一峰 JavaScript 教程》</a>做的笔记。</sup></p>
</blockquote>
<p>面向对象编程（Object Oritented Programming，缩写 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。</p>
<p>每个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。</p>
<p>那么，“对象”（object）到底是什么？我们从两个层次来理解。</p>
<p>（1）对象是单个实物的抽象。</p>
<p>一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。</p>
<p>（2）对象是一个容器，封装了属性（property）和方法（method）。</p>
<p>属性是对象的状态，方法是对象的行为（完成某项任务）。比如，我们可以把动物抽象成 animal 对象，使用属性记录具体是哪一种动物，使用方法表示动物的某种行为（奔跑、捕猎、休息等等）。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一个类实物的共同特征，然后对象根据这个模板生成。</p>
<p>典型的面向对象编程语言（比如 C++ 和 Java），都有类（class）这个概念。所谓类就是对象的模板，对象就是类的实例。但是 JavaScript 语言的对象体系，不是基于类的，而是基于构造函数和原型链的。</p>
<p>JavaScript 语言使用构造函数作为对象的模板。所谓构造函数，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。</p>
<p>构造函数就是一个普通函数，但是有它自己的特征和用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Vehicle 就是构造函数。为了与普通函数区别，构造函数名字的第一个字母要大写。</p>
<p>构造函数的特点有两个：</p>
<ul>
<li>函数体内部使用了 this 关键字，代表了所要生成的对象实例</li>
<li>生成对象的时候，必须使用 new 命令。</li>
</ul>
<h3 id="new-命令"><a href="#new-命令" class="headerlink" title="new 命令"></a>new 命令</h3><p>new 命令的作用，就是执行构造函数，返回一个实例对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle();</span><br><span class="line">v.price = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>
<p>通过 new 命令，让构造函数 Vehicle 生成一个实例对象，保存在变量 v 中。这个新生成的实例对象，从构造函数 Vehicle 得到了 price 属性。new 命令执行时，构造函数内部 this，就代表了新生成的实例对象，this.price 表示实例对象有一个 price 属性，值为 1000。</p>
<p>使用 new 命令时，根据需要，构造函数也可以接受参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle(<span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<p>new 命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle()</span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle <span class="comment">// 不推荐</span></span><br></pre></td></tr></table></figure>
<p>如果忘记了 new 命令，直接调用构造函数，构造函数会变成普通函数，并不会生成实例对象。如下代码，this 这时代表全局对象，将造成一些意想不到的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> v = Vehicle()</span><br><span class="line">v <span class="comment">// undefined</span></span><br><span class="line">price <span class="comment">// 1000 此时 Vehicle 的 this 指向的是全局对象</span></span><br></pre></td></tr></table></figure>
<p>可以在构造函数体内第一行加上 use strict 给构造函数使用严格模式，这个时候如果忘记了 new，引擎会报错。</p>
<p>或者… 在构造函数内部判断是否使用 new 命令，如果发现没有使用，则直接返回一个实例对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fubar</span>(<span class="params">foo, bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> instance <span class="keyword">of</span> Fubar)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Fubar(foo, bar);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._foo = foo;</span><br><span class="line">  <span class="keyword">this</span>._bar = bar;</span><br><span class="line">&#125;</span><br><span class="line">Fubar(<span class="number">1</span>, <span class="number">2</span>)._foo <span class="comment">// 1</span></span><br><span class="line">(<span class="keyword">new</span> Fubar(<span class="number">1</span>, <span class="number">2</span>))._foo <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>这样就不管加没加 new 命令，都会得到同样的结果了。</p>
<h4 id="new-命令的原理"><a href="#new-命令的原理" class="headerlink" title="new 命令的原理"></a>new 命令的原理</h4><p>使用 new 命令时，它后面的函数依次执行下面的步骤：</p>
<ol>
<li>创建一个空对象，作为将要返回的对象实例</li>
<li>将这个空对象的原型，指向构造函数的 prototype 属性</li>
<li>将这个空对象赋值给函数内部的 this 关键字</li>
<li>开始执行构造函数内部的代码</li>
</ol>
<p>也就是说，构造函数内部，this 指的是一个新生成的空对象，所有针对 this 的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（this 对象），将其“构造”为需要的样子。</p>
<p>如果构造函数内部有 return 语句，而且 return 后面跟着一个对象，new 命令会返回 return 语句指定的对象；否则不管 return 语句，返回 this 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> Vehicle()) === <span class="number">1000</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>return 返回 1000，new 命令直接忽略掉了这个 return 语句，返回构造后的 this 对象。</p>
<p>但是，如果是 return 语句返回的是一个跟 this 无关的新对象，new 命令会返回这个新对象，而不是 this 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">price</span>: <span class="number">2000</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> Vehicle()).price</span><br><span class="line"><span class="comment">// 2000</span></span><br></pre></td></tr></table></figure>
<p>如果是普通函数（内部没有 this 关键字的函数）使用 new 命令，则会返回一个空对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">functino a() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'a'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> aa = <span class="keyword">new</span> a()</span><br><span class="line">aa <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="keyword">typeof</span> aa <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure>
<p>new 命令简化的内部流程，可以用下面的代码表示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">constructor, params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">constructor</span> = args.shift();</span><br><span class="line">  var context = Object.create(<span class="keyword">constructor</span>.prototype);</span><br><span class="line">  var result = <span class="keyword">constructor</span>.apply(context, args);</span><br><span class="line">	return (typeof result === 'object' &amp;&amp; result !== null) ? result : context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实例</span><br><span class="line">var actor = _new(Person, '张三', 28)</span><br></pre></td></tr></table></figure>
<h4 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h4><p>函数内部可以使用 new.target 属性。如果当前函数是 new 命令调用，new.target 指向当前函数，否则为 undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span>.target ==== f)</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// false</span></span><br><span class="line"><span class="keyword">new</span> f() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>使用这个属性，可以判断函数调用的时候，是否使用 new 命令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'请使用 new 命令调用！'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// Uncaught Error: 请使用 new 命令调用！</span></span><br></pre></td></tr></table></figure>
<h3 id="Object-create-创建实例对象"><a href="#Object-create-创建实例对象" class="headerlink" title="Object.create() 创建实例对象"></a>Object.create() 创建实例对象</h3><p>构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，知恩感拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例丢下，这时就可以使用 Object.create 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  age: <span class="number">38</span>,</span><br><span class="line">  greeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi! I\'m'</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person1)</span><br><span class="line">person2.name <span class="comment">// 张三</span></span><br><span class="line">person2.greeting() <span class="comment">// Hi! I'm 张三</span></span><br></pre></td></tr></table></figure>

  </div>
  
</article>
    </main>
    <footer>
  <p>&copy; 2019 code.dsphoebe.com <wbr> <a href="http://www.miitbeian.gov.cn/">京ICP备15048606号-1</a></p>
</footer>
  </body>
</html>
