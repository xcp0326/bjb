<!Doctype html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <title>为什么 0.1 + 0.2 === 0.30000000000000004 | FE NOTEBOOK 🚀</title>
  
    <link rel="icon" href="/images/favico.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/bjb/style/gitalk.css">
  <link rel="stylesheet" href="/bjb/style/style.css">
  <script src="/bjb/js/gitalk.min.js"></script>
</head>
  <body>
    <header class="header">
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/bjb/" class="menu-item-link">首页</a>
        </li>
      
        <li class="menu-item">
          <a href="/bjb/archives" class="menu-item-link">归档</a>
        </li>
      
    </ul>
  </nav>
  <h1 class="pc">FE NOTEBOOK 🚀</h1>
  <h1 class="mobile"><a href="/">FE NOTEBOOK 🚀</a></h1>
  <em>「 学海无涯，没空撩妹！」</em>
</header>
    <main class="main">
      <article class="post">
  <div class="post-title">
    <h2 class="title">为什么 0.1 + 0.2 === 0.30000000000000004</h2>
  </div>
  <div class="post-meta">
    <span class="post-time">2018-11-19 16:13:29</span>
    <span class="post-tags">
      
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/bjb/tags/IEE-754/">IEE 754</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/bjb/tags/二进制/">二进制</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/bjb/tags/双精度浮点数/">双精度浮点数</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/bjb/tags/浮点数/">浮点数</a></li></ul>
      
    </span>
    
  </div>
  <div class="post-content">
    <h2 id="双精度浮点数的概念"><a href="#双精度浮点数的概念" class="headerlink" title="双精度浮点数的概念"></a>双精度浮点数的概念</h2><p>双精度浮点数是JavaScript 的数值使用的数值形式，又称 64 位浮点数，由 IEE 754 （电气和电子工程师协会）制定的标准。</p>
<p>64 位浮点数的二进制位是由三个部分组成：</p>
<p><img src="/images/float/float.png" alt="64 位浮点数的二进制位组成部分"></p>
<p>从左到右：</p>
<ul>
<li>第 1 位 为 Sign 位，即符号位，表示浮点数是否是负数，所以说 1 就表示浮点数是负数，0 则表示是正数</li>
<li>从第 2 位到到 12 位，共 11 位，是指数部分。<br>类似于科学计数法中的 <code>M*10^N</code>中的 N，只是这里的 10 替换成了 2 。<br>这部分中以<code>2^10-1</code>即<code>1023</code>，也即 1111111111<code>代表 2^0</code>，转换时需要根据 1023 作偏移调整。</li>
<li>从第 13 位到第 64 位，共 52 位，是小数部分，是浮点数具体数值的实际表示。</li>
</ul>
<h2 id="浮点数转换到二进制"><a href="#浮点数转换到二进制" class="headerlink" title="浮点数转换到二进制"></a>浮点数转换到二进制</h2><p><strong>第一步：改写整数部分</strong></p>
<p>以 <code>5.2</code>为例。先不考虑指数部分，单纯的将十进制转换成二进制。整数部分很简单，十进制 <code>5</code> 转换成二进制为 <code>101</code>。</p>
<p><strong>第二步：改写小数部分</strong></p>
<p>0.2 的二进制转换，数值乘以 2，如果乘法计算的结果（&gt; = 1.0）也就是有整数部分，则该位的值为 1，然后将剩余的小数部分用于下一次计算。直到结果为 1.0，转换结束。</p>
<table>
<thead>
<tr>
<th>位置</th>
<th>计算</th>
<th>结果</th>
<th>整数</th>
<th>位值</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>.2 x 2</td>
<td>.4</td>
<td>no</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>.4 x 2</td>
<td>.8</td>
<td>no</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>.8 x 2</td>
<td>1.6</td>
<td>yes</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>.6 x 2</td>
<td>1.2</td>
<td>yes</td>
<td>1</td>
</tr>
<tr>
<td>5 同第 1 位</td>
<td>.2 x 2</td>
<td>.4</td>
<td>no</td>
<td>0</td>
</tr>
<tr>
<td>6 同第 2 位</td>
<td>.4 x 2</td>
<td>.8</td>
<td>no</td>
<td>0</td>
</tr>
<tr>
<td>7 同第 3 位</td>
<td>.8 x 2</td>
<td>1.6</td>
<td>yes</td>
<td>1</td>
</tr>
<tr>
<td>8 同第 4 位</td>
<td>.6 x 2</td>
<td>1.2</td>
<td>yes</td>
<td>1</td>
</tr>
<tr>
<td>9 同第 1 位</td>
<td>.2 x 2</td>
<td>.4</td>
<td>no</td>
<td>0</td>
</tr>
<tr>
<td>10 同第 2 位</td>
<td>.4 x 2</td>
<td>.8</td>
<td>no</td>
<td>0</td>
</tr>
<tr>
<td>11 同第 3 位</td>
<td>.8 x 2</td>
<td>1.6</td>
<td>yes</td>
<td>1</td>
</tr>
<tr>
<td>12 同第 4 位</td>
<td>.6 x 2</td>
<td>1.2</td>
<td>yes</td>
<td>1</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>可以看出 0.2 的二进制值无法达到结果为 1.0 的情况，而是 .4，.8，1.6，1.2 一直循环，也就是二进制位值 0011 四位无限循环。二进制表示为：<code>0.001100110011....</code></p>
<p><strong>第三步：规格化</strong></p>
<p>现在我们有了这么一串二进制 <code>101.0011001100110011....</code>。然后我们要将它规格化，也叫 Normalize。</p>
<p>其实原理很简单就是包装小数点前只有一个 bit。</p>
<p>于是我们就得到了一下表示：<code>1.0100110011001100110011*2^2</code>。到此我们已经把改写工作完成，接下来要把 bit 填充到三个组成部分中去了。</p>
<p><strong>第四步：填充</strong></p>
<p>指数部分 Exponent：需要以 1023 作为偏移量调整。因此 2 的 2 次方，指数部分偏移成 2 + 1023 即 1025，表示成<code>10000000001</code>填入。</p>
<p>尾数部分 Mantissa：除了简单的填入外，需要特别解释的地方是 <code>1.010011</code> 中的整数部分 1 在填充时被舍去了。因为规格化后的数值整数部分总为 1。对于任何科学记数法，小数点始终移动到最左侧位置，以便没有前导零。例如，0.234 x 10<sup>2</sup> 或 0.365 x 10<sup>5</sup>。这些数字将写成 2.34 x 10<sup>1</sup> 和 3.65 x 10<sup>4</sup>。同样的规则用于二进制科学记数法，这意味着任何标准化的科学二进制数都以 1 开头。既然确认知道是 1，所以为了节省空间，这一位的 1 就被省略了。</p>
<p>具体填充后的结果见下图：</p>
<p><img src="/images/float/float2.png" alt="64 位浮点数的二进制位组成部分"></p>
<h2 id="为什么-0-1-0-2-0-30000000000000004"><a href="#为什么-0-1-0-2-0-30000000000000004" class="headerlink" title="为什么 0.1 + 0.2 === 0.30000000000000004"></a>为什么 0.1 + 0.2 === 0.30000000000000004</h2><p>现在我们按照上面的分析来分析下 0.1 + 0.2 为什么等于 0.30000000000000004</p>
<h3 id="0-1-转换为二进制"><a href="#0-1-转换为二进制" class="headerlink" title="0.1 转换为二进制"></a><code>0.1</code> 转换为二进制</h3><table>
<thead>
<tr>
<th>计算次数</th>
<th>计算</th>
<th>结果</th>
<th>整数</th>
<th>位值</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>.1 x 2</td>
<td>.2</td>
<td>no</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>.2 x 2</td>
<td>.4</td>
<td>no</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>.4 x 2</td>
<td>.8</td>
<td>no</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>.8 x 2</td>
<td>1.6</td>
<td>yes</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>.6 x 2</td>
<td>1.2</td>
<td>yes</td>
<td>1</td>
</tr>
<tr>
<td>6 同第 2 位</td>
<td>.2 x 2</td>
<td>.4</td>
<td>no</td>
<td>0</td>
</tr>
<tr>
<td>7 同第 3 位</td>
<td>.4 x 2</td>
<td>.8</td>
<td>no</td>
<td>0</td>
</tr>
<tr>
<td>8 同第 4 位</td>
<td>.8 x 2</td>
<td>1.6</td>
<td>yes</td>
<td>1</td>
</tr>
<tr>
<td>9 同第 5 位</td>
<td>.6 x 2</td>
<td>1.2</td>
<td>yes</td>
<td>1</td>
</tr>
<tr>
<td>10 同第 2 位</td>
<td>.2 x 2</td>
<td>.4</td>
<td>no</td>
<td>0</td>
</tr>
<tr>
<td>11 同第 3 位</td>
<td>.4 x 2</td>
<td>.8</td>
<td>no</td>
<td>0</td>
</tr>
<tr>
<td>12 同第 4 位</td>
<td>.8 x 2</td>
<td>1.6</td>
<td>yes</td>
<td>1</td>
</tr>
<tr>
<td>13 同第 5 位</td>
<td>.6 x 2</td>
<td>1.2</td>
<td>yes</td>
<td>1</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>可以看出 0.1 的二进制值也是无法达到结果为 1.0 的情况的，而是 .4，.8，1.6，1.2 一直循环，也就是二进制位值 0011 四位无限循环。二进制表示为：0.0001100110011….</p>
<h3 id="0-1-二进制规格化："><a href="#0-1-二进制规格化：" class="headerlink" title="0.1 二进制规格化："></a>0.1 二进制规格化：</h3><ul>
<li>符号位<ul>
<li>不是负数 所以符号位为 0</li>
</ul>
</li>
<li>指数位<ul>
<li>科学计数法，浮点数的小数点往后移动 4 位，表示为 1.100110011….x2^-4，方便计算计数部分就不再规格化为二进制。</li>
</ul>
</li>
<li>尾数位<ul>
<li>无限循环的最大值为 64 位浮点数制定的最大尾数位 52 位，所以表示为1001100110011001100110011001100110011001100110011010</li>
</ul>
</li>
</ul>
<p>方便后续计算表示为：<br>0.1 = 1.1001100110011001100110011001100110011001100110011010 x 2^-4</p>
<h3 id="0-2-转换为二进制"><a href="#0-2-转换为二进制" class="headerlink" title="0.2 转换为二进制"></a>0.2 转换为二进制</h3><p>从上面的案例我们已经得到了 0.2 的二进制数为：.001100110011….</p>
<h3 id="0-2-二进制规格化"><a href="#0-2-二进制规格化" class="headerlink" title="0.2 二进制规格化"></a>0.2 二进制规格化</h3><ul>
<li>符号位<ul>
<li>不是负数，所以是 0</li>
</ul>
</li>
<li>指数位<ul>
<li>.001100110011…. 小数点往后挪 3 位，表示为 1.100110011….x2^-3，方便计算计数部分就不再规格化为二进制。</li>
</ul>
</li>
<li>尾数位<ul>
<li>同 0.1 的尾数，0.2 的尾数也是 1001100110011001100110011001100110011001100110011010</li>
</ul>
</li>
</ul>
<p>方便后续计算表示为：<br>0.2 = 1.1001100110011001100110011001100110011001100110011010 x 2^-3</p>
<h3 id="0-1-的-64-位二进制-0-2-的-64-位二进制"><a href="#0-1-的-64-位二进制-0-2-的-64-位二进制" class="headerlink" title="0.1 的 64 位二进制 + 0.2 的 64 位二进制"></a>0.1 的 64 位二进制 + 0.2 的 64 位二进制</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> = <span class="number">2</span>^<span class="number">-3</span> *  <span class="number">0.1100110011001100110011001100110011001100110011001101</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">0.2</span> = <span class="number">2</span>^<span class="number">-3</span> *  <span class="number">1.1001100110011001100110011001100110011001100110011010</span></span><br><span class="line">sum = <span class="number">2</span>^<span class="number">-3</span> * <span class="number">10.0110011001100110011001100110011001100110011001100111</span></span><br></pre></td></tr></table></figure>
<p>即</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sum = <span class="number">2</span>^<span class="number">-2</span> * <span class="number">1.0011001100110011001100110011001100110011001100110011</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>sum 转换为十进制为 0.3000000000004</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>转换为整数计算，计算完后返回小数点的位置</p>
<p>0.1 + 0.2 转换为 1 + 2 等于 3，再转换为小数 0.3</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> plus = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> num1DotPos = num1.toString().split(<span class="string">'.'</span>)[<span class="number">1</span>].length</span><br><span class="line">  <span class="keyword">const</span> num1Int = num1 * (<span class="number">10</span> ** num1DotPos)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> num2DotPos = num2.toString().split(<span class="string">'.'</span>)[<span class="number">1</span>].length</span><br><span class="line">  <span class="keyword">const</span> num2Int = num2 * (<span class="number">10</span> ** num2DotPos)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> numDotPos = <span class="built_in">Math</span>.max(num1DotPos, num2DotPos)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (num1Int + num2Int) / (<span class="number">10</span> ** numDotPos)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plus(<span class="number">0.1</span>, <span class="number">0.2</span>) <span class="comment">// 0.3</span></span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://cenalulu.github.io/linux/about-denormalized-float-number/" target="_blank" rel="noopener">你应该知道的浮点数基础知识</a><br><a href="/2018/11/19/二进制数与浮点数的转换/">译文：二进制数与浮点数的转换</a><br><a href="https://www.cnblogs.com/fsjohnhuang/p/5115672.html" target="_blank" rel="noopener">JS魔法堂：彻底理解0.1 + 0.2 === 0.30000000000000004的背后</a><br><a href="https://stackoverflow.com/questions/588004/is-floating-point-math-broken/588014#answer-28679423" target="_blank" rel="noopener">Is floating point math broken?</a><br><a href="http://0.30000000000000004.com/" target="_blank" rel="noopener">http://0.30000000000000004.com/</a><br><a href="https://github.com/camsong/blog/issues/9" target="_blank" rel="noopener">JavaScript 浮点数陷阱及解法</a></p>

  </div>
  
</article>
    </main>
    <footer>
  <p>&copy; 2019 bjb.dsphoebe.com <wbr> <a href="http://www.miitbeian.gov.cn/">京ICP备15048606号-1</a></p>
</footer>
  </body>
</html>
