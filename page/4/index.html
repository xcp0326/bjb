<!Doctype html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <title>FE 笔记本 🚀</title>
  
    <link rel="icon" href="/images/favico.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/bjb/style/gitalk.css">
  <link rel="stylesheet" href="/bjb/style/style.css">
  <script src="/bjb/js/gitalk.min.js"></script>
</head>
  <body>
    <header class="header">
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/bjb/" class="menu-item-link">首页</a>
        </li>
      
        <li class="menu-item">
          <a href="/bjb/archives" class="menu-item-link">归档</a>
        </li>
      
    </ul>
  </nav>
  <h1 class="pc">FE 笔记本 🚀</h1>
  <h1 class="mobile"><a href="/">FE 笔记本 🚀</a></h1>
  <em>「 学海无涯，没空撩妹！」</em>
</header>
    <main class="main">
      
  <article class="post">
  <div class="post-title">
    <h2 class="title">IndexedDB</h2>
  </div>
  <div class="post-meta">
    <span class="post-time">2019-06-03 15:49:19</span>
    <span class="post-tags">
      
    </span>
    
  </div>
  <div class="post-content">
    <p>现有的浏览器数据储存方案，Cookie 4kb，且每次请求都会发送回服务器；LocalStorage 在 2.5M 到 10M 之间（各浏览器不同），不能搜索不能建索引。这就是 IndexDB 出现的场景。</p>
<p>IndexDB 更接近 NoSQL 数据库</p>
<p>特点：</p>
<p>键值对储存、同源策略、</p>
<p>异步：IndexDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的 🤔。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p>
<p>支持事务：transaction，这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>
<p>储存空间大：一般不少于 250M，甚至没有设置上限</p>
<p>支持二进制储存：不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）</p>
<p>数据库是一系列相关数据的容器。每个域名都可以新建任意多个数据库。IndexDB 数据库有版本的概念。同一个时刻，只能有一个版本的数据库存在。如果修改数据库结构（新增、索引或主键），只能通过升级数据库版本完成。</p>
<p>每个数据库有若干个对象仓库，它类似于关系数据库的表格。</p>
<p>对象仓库保存的是数据记录。每条记录类似于关系数据库的行，但是只有主键和数据体两部分。主键用来建立默认的索引，必须是不同的，否则会报错。主键可以是数据记录里面的一个属性，也可以指定为一个递增的整数编号。比如 id 就可以作为主键。数据体可以是任意数据类型，不限于对象。</p>
<p>为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引。</p>
<p>数据记录的读写和删改，都要通过事务完成。事务对象提供 error、abort 和 complete 三个时间，用来监听操作结果。</p>
<h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="built_in">window</span>.indexedDB.open(databaseName, version);</span><br><span class="line"><span class="keyword">let</span> db;</span><br><span class="line">request.onerror = <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'数据库打开发生错误'</span>);</span><br><span class="line">request.onsuccess = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  db = request.result;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'成功打开一个数据库'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果指定的 version 大于数据库版本号，就会升级</span></span><br><span class="line">request.onupgradeneeded = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  db = event.target.result; <span class="comment">// 拿到数据库实例，</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="新建数据库"><a href="#新建数据库" class="headerlink" title="新建数据库"></a>新建数据库</h4><p>打开数据库时，如果指定的数据库不存在就会自动新建并触发 <code>upgradeneeded</code> 函数。</p>
<p>新建对象仓库，设置主键，新建索引。下一层对象的属性可以指定为主键。可以自动生成主键（autoIncrement: true)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request.onupgradeneeded = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  db = event.target.result;</span><br><span class="line">  <span class="keyword">const</span> objectStore = db.createObjectStore(<span class="string">'person'</span>, &#123;<span class="attr">keyPath</span>: <span class="string">'id'</span>&#125;);</span><br><span class="line">  objectStore.createIndex(<span class="string">'name'</span>, <span class="string">'name'</span>, &#123;<span class="attr">unique</span>: <span class="literal">false</span>&#125;); </span><br><span class="line">  objectStore.createIndex(<span class="string">'email'</span>, <span class="string">'email'</span>, &#123;<span class="attr">unique</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">  <span class="comment">// objectStore.createIndex(索引名称，索引所在的属性，配置对象)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h4><p>通过事务来完成向对象仓库写入数据记录来新增数据。是一个异步操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> request = db.transaction([<span class="string">'person'</span>], <span class="string">'readwrite'</span>)</span><br><span class="line">  	.objectStore(<span class="string">'person'</span>)</span><br><span class="line">  	.add(&#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'xx'</span>, <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">email</span>: <span class="string">'z@z.com'</span>&#125;);</span><br><span class="line">  </span><br><span class="line">  request.onsuccess = <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'数据写入成功'</span>);</span><br><span class="line">  </span><br><span class="line">  request.onerror = <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'数据写入失败'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">add();</span><br></pre></td></tr></table></figure>
<h4 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> read = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> transaction = db.transaction([<span class="string">'person'</span>]);</span><br><span class="line">  <span class="keyword">const</span> objectStore = transaction.objectStore(<span class="string">'person'</span>);</span><br><span class="line">  <span class="keyword">const</span> request = objectStore.get(<span class="number">1</span>); <span class="comment">// 1 是主键的值.</span></span><br><span class="line">  </span><br><span class="line">  request.onerror = <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'读取失败'</span>);</span><br><span class="line">  </span><br><span class="line">  request.onsuccess = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.result) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Name: '</span> + request.result.name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'未获得数据记录'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">read();</span><br></pre></td></tr></table></figure>
<h4 id="遍历数据"><a href="#遍历数据" class="headerlink" title="遍历数据"></a>遍历数据</h4><p>使用 IDBCursor 指针对象便利数据对象的所有记录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> readAll = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> objectStore = db.transaction(<span class="string">'person'</span>).objectStore(<span class="string">'person'</span>);</span><br><span class="line">  objectStore.openCursor().onsuccess = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"> 		<span class="keyword">const</span> cursor = event.target.result;</span><br><span class="line">    <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Id: '</span> + cursor.key);</span><br><span class="line">      cursor.continue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'没有数据了'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">readAll();</span><br></pre></td></tr></table></figure>
<p>openCursor() 方法是一个异步操作，所以要监听 success 事件。</p>
<h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> update = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> request = db.transaction([<span class="string">'person'</span>], <span class="string">'readwrite'</span>)</span><br><span class="line">  	.objectStore(<span class="string">'person'</span>)</span><br><span class="line">  	.put(&#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'zzz'</span>, <span class="attr">age</span>: <span class="number">12</span>, <span class="attr">email</span>: <span class="string">'1z@z.com'</span>&#125;);</span><br><span class="line">  request.onsuccess = <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'更新成功'</span>);</span><br><span class="line">  request.onerror = <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'更新失败'</span>);</span><br><span class="line">&#125;</span><br><span class="line">update();</span><br></pre></td></tr></table></figure>
<h4 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> request = db.transaction([<span class="string">'person'</span>], <span class="string">'readwrite'</span>)</span><br><span class="line">    .objectStore(<span class="string">'person'</span>)</span><br><span class="line">    .delete(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据删除成功'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">remove();</span><br></pre></td></tr></table></figure>
<p>索引是让你可以搜索任意字段，也就是说从任意字段拿到数据记录。</p>
<p>对 name 字段建立索引 <code>objectStore.createIndex(&#39;name&#39;, &#39;name&#39;, {unique: false})</code> </p>
<p>然后就可以用 name 来搜索对应的数据记录了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.transaction([<span class="string">'person'</span>], <span class="string">'readonly'</span>);</span><br><span class="line"><span class="keyword">const</span> store = transaction.objectStore(<span class="string">'person'</span>);</span><br><span class="line"><span class="keyword">const</span> index = store.index(<span class="string">'name'</span>);</span><br><span class="line"><span class="keyword">const</span> request = index.get(<span class="string">'李四'</span>);</span><br><span class="line"></span><br><span class="line">request.onsuccess = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = event.target.result;</span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="indexedDB-deleteDatabase"><a href="#indexedDB-deleteDatabase" class="headerlink" title="indexedDB.deleteDatabase()"></a>indexedDB.deleteDatabase()</h4><p>删除数据库后，当前数据库的其他已经打开的链接都会接收到 versionchange 事件</p>
<h4 id="indexedDB-cmp"><a href="#indexedDB-cmp" class="headerlink" title="indexedDB.cmp()"></a>indexedDB.cmp()</h4><p>比较两个值是否为 indexedDB 的相同的主键 🤔 没明白场景是啥</p>
<h4 id="IDBRequest-对象"><a href="#IDBRequest-对象" class="headerlink" title="IDBRequest 对象"></a>IDBRequest 对象</h4><p>indexedDB.open() 和 indexedDB.deleteDatabase() 会返回这个对象。数据库的操作都是通过这个对象来完成的。是异步操作。通过 readyState （pending | done）表示状态。</p>
<ul>
<li>IDBRequest.readyState</li>
<li>IDBRequest.result</li>
<li>IDBRequest.error</li>
<li>IDBRequest.source</li>
<li>IDBRequest.transaction</li>
<li>IDBRequest.onsuccess</li>
<li>IDBRequest.onerror</li>
<li>IDBOpenDBRequest.onblocked</li>
<li>IDBOpenDBRquest.onupgradeneeded</li>
</ul>
<h4 id="IDBDatabase-对象"><a href="#IDBDatabase-对象" class="headerlink" title="IDBDatabase 对象"></a>IDBDatabase 对象</h4><p>打开数据成功以后，可以从 IDBOpenDBRequest 对象的 result 属性上面，拿到一个 IDBDatabase 对象，</p>
<p>… </p>
<h4 id="IDBObjectStore-对象"><a href="#IDBObjectStore-对象" class="headerlink" title="IDBObjectStore 对象"></a>IDBObjectStore 对象</h4><h4 id="IDBTransaction-对象"><a href="#IDBTransaction-对象" class="headerlink" title="IDBTransaction 对象"></a>IDBTransaction 对象</h4><p>用来异步操作数据库事务，所有数据库的读写操作都要通过这个对象进行。事务 tranaction 这个词先前在 React router 源码见过。事务… 🤔</p>
<h4 id="IDBIndex-对象"><a href="#IDBIndex-对象" class="headerlink" title="IDBIndex 对象"></a>IDBIndex 对象</h4><p>代表数据库的索引，通过这个对象可以获取数据库里面的记录。数据记录的主键默认是带有索引，IDBIndex 对象主要用于通过除主键意外的其他键，建立索引获取对象。IDBIndex 是持久性（🤔 有不持久的存储）的键值对存储。只要插入、更新或删除数据记录，引用的对象库中的记录，索引就会自动更新。</p>
<h4 id="IDBCursor-对象"><a href="#IDBCursor-对象" class="headerlink" title="IDBCursor 对象"></a>IDBCursor 对象</h4><p>用来遍历数据仓库 IDBObjectStore 或索引 IDBIndex 的记录。</p>
<h4 id="IDBKeyRange-对象"><a href="#IDBKeyRange-对象" class="headerlink" title="IDBKeyRange 对象"></a>IDBKeyRange 对象</h4><p>有一个实例方法 includes(key)，返回一个布尔值，表示某个主键是否包含在当前这个主键组之内。🤔 这大概是它的场景吧？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> keyRangeValue = IDBKeyRange.bound(<span class="string">'A'</span>, <span class="string">'K'</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">keyRangeValue.includes(<span class="string">'F'</span>)<span class="comment">// true</span></span><br><span class="line">keyRangeValue.includes(<span class="string">'W'</span>)<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

  </div>
  
</article>


  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/bjb/page/3/">&laquo;上一页</a><a class="page-number" href="/bjb/">1</a><a class="page-number" href="/bjb/page/2/">2</a><a class="page-number" href="/bjb/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/bjb/page/5/">5</a><a class="page-number" href="/bjb/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/bjb/page/77/">77</a><a class="extend next" rel="next" href="/bjb/page/5/">下一页&raquo;</a>
  </nav>

    </main>
    <footer>
  <p>&copy; 2019 xcp0326</p>
</footer>
  </body>
</html>
