<!Doctype html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <title>FE 笔记本 🚀</title>
  
    <link rel="icon" href="/images/favico.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/bjb/style/gitalk.css">
  <link rel="stylesheet" href="/bjb/style/style.css">
  <script src="/bjb/js/gitalk.min.js"></script>
</head>
  <body>
    <header class="header">
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/bjb/" class="menu-item-link">首页</a>
        </li>
      
        <li class="menu-item">
          <a href="/bjb/archives" class="menu-item-link">归档</a>
        </li>
      
    </ul>
  </nav>
  <h1 class="pc">FE 笔记本 🚀</h1>
  <h1 class="mobile"><a href="/">FE 笔记本 🚀</a></h1>
  <em>「 学海无涯，没空撩妹！」</em>
</header>
    <main class="main">
      
  <article class="post">
  <div class="post-title">
    <h2 class="title">Node 接口</h2>
  </div>
  <div class="post-meta">
    <span class="post-time">2018-12-24 23:36:09</span>
    <span class="post-tags">
      
    </span>
    
  </div>
  <div class="post-content">
    <blockquote>
<p><sup>这里是我读<a href="https://wangdoc.com/javascript/" target="_blank" rel="noopener">《阮一峰 JavaScript 教程》</a>做的笔记。</sup></p>
</blockquote>
<p>所有的 DOM 节点都继承自 Node 接口，所有的 DOM 节点都共有 DOM.prototype 下的方法和属性。</p>
<p>nodeType</p>
<ul>
<li>文档节点：9</li>
<li>元素节点：1</li>
<li>属性节点：2</li>
<li>文本节点：3</li>
<li>文档片段节点：11</li>
<li>文档类型节点：10</li>
<li>注释节点：8</li>
</ul>
<p>nodeName</p>
<ul>
<li>文档节点：#document</li>
<li>元素节点：大写标签名，除了 SVG 是小写标签名，因为是后来添加的。</li>
<li>属性节点：属性的名称</li>
<li>文本节点：#text</li>
<li>文档片段节点：#document-fragment</li>
<li>文档类型节点：文档的类型</li>
<li>注释节点：#comment</li>
</ul>
<p>nodeValue：节点的文本值，所以只有文本节点、注释节点、属性节点才有 nodeValue 值。其他类型的节点都返回 null。</p>
<p>textContext：返回当前节点及其后代节点的文本内容。它会自动对 HTML 标签转义。文本节点、注释节点、属性节点的值和 nodeValue 一样。文档节点和文档类型节点的 textContent 属性为 null。读取整个文档的内容为 document.document.textContent.</p>
<p>baseURI：只读，一般由当前网页的 URL window.location 决定，可以使用<code>&lt;base&gt;</code>标签修改。用来计算网页上的相对路径的 URL。</p>
<p>nextSibling：当前节点的下一个节点，如果没有返回 null，用来遍历所有子节点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = <span class="built_in">document</span>.querySelector(<span class="string">'.el'</span>)</span><br><span class="line"><span class="keyword">const</span> el = parent.firstChild</span><br><span class="line"><span class="keyword">while</span>(el !== <span class="literal">null</span>) &#123;</span><br><span class="line">  el = el.nextSibling</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>prevSibling：当前节点的上一个节点，如果没有就返回 null，同 nextSibling 原理，也可以用来遍历所有子节点。</p>
<p>parentNode：对于一个节点来说，它的父节点可能是三种类型：元素节点、文档节点、文档片段节点。</p>
<p>childNodes：返回节点的子节点 NodeList 伪数组动态集合</p>
<p>isConnected：返回节点是否在文档之中</p>
<p>appendChild()：插入一个节点，并作为当前节点最后一个节点，相当于生的最后一个儿子。返回这个节点。如果参数是 DocumentFragment 节点，那么插入的是 DocumentFragment 的所有子节点，而不是 DocumentFragment 节点本身。返回值是一个空的 DocumentFragment 节点。</p>
<p>hasChildNodes()：遍历当前节点的所有后代节点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DOMComb</span>(<span class="params">parent, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent.hasChildNodes()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> node = parent.firstChild; node; node = node.nextSibling) &#123;</span><br><span class="line">      DOMComb(node, callback)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callback(parent)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DOMComb(<span class="built_in">document</span>.body, <span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<p>cloneNode()：参数表示是否深度 clone，返回克隆的新节点。只克隆 DOM 里面带的属性，如果有 id 或者 name 属性，需要修改 clone 出来的节点的 id 和 name 属性。</p>
<p>insertBefore()：将第一个参数插入当前节点内的某个子节点即第二个参数前，返回新节点。如果第二个参数为 null，则是将节点插入到当前节点内部的最后的位置，也就是 appendChild 一样了。node 节点插入到 nnode 节点后：<code>parent.insertBefore(node, nnode.nextSibling)</code>。同 appendChild 方法，如果参数是 DocumentFragment 节点，那么插入的是 DocumentFragment 的所有子节点，而不是 DocumentFragment 节点本身。返回值是一个空的 DocumentFragment 节点。</p>
<p>replaceChild：第一个参数节点替换第二个参数节点，返回第二个参数节点</p>
<p>contains()：返回节点是否在当前文档中。确定参数节点为当前节点，参数节点是否为当前节点的子节点，参数节点是否为当前节点的后代节点。</p>
<p>compareDocumentPosition()：用法和 contains 一样，返回一个 6 bit 位的二进制值，表示参数节点与当前节点的关系</p>
<table>
<thead>
<tr>
<th>二进制值</th>
<th>十进制值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>000000</td>
<td>0</td>
<td>两个节点相同</td>
</tr>
<tr>
<td>000001</td>
<td>1</td>
<td>两个节点不在同一个文档（即有一个节点不在当前文档）</td>
</tr>
<tr>
<td>000010</td>
<td>2</td>
<td>参数节点在当前节点的前面</td>
</tr>
<tr>
<td>000100</td>
<td>4</td>
<td>参数节点在当前节点的后面</td>
</tr>
<tr>
<td>001000</td>
<td>8</td>
<td>参数节点包含当前节点</td>
</tr>
<tr>
<td>010000</td>
<td>16</td>
<td>当前节点包含参数节点</td>
</tr>
<tr>
<td>100000</td>
<td>32</td>
<td>浏览器内部使用</td>
</tr>
</tbody>
</table>
<p>通过掩码进行运算，简称某个特定位置的标签嵌套是否合乎规范：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.head;</span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="keyword">if</span> (head.compareDocumentPosition(body) &amp; <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'文档结构正确'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'&lt;body&gt; 不能在 &lt;head&gt; 前面'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isEqualNode() 节点与参数节点是否相等</p>
<p>isSameNode() 节点与参数节点是否为同一个节点</p>
<p>normalize() 去除节点文本节点之间的多余空格</p>
<p>getRootNode() 返回所在文档的根节点 <code>document</code>，与 <code>ownerDocument</code> 属性的作用相同。它可以在 document 节点自身，这一点与 document.ownerDocument 不同。</p>

  </div>
  
</article>


  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/bjb/page/46/">&laquo;上一页</a><a class="page-number" href="/bjb/">1</a><span class="space">&hellip;</span><a class="page-number" href="/bjb/page/45/">45</a><a class="page-number" href="/bjb/page/46/">46</a><span class="page-number current">47</span><a class="page-number" href="/bjb/page/48/">48</a><a class="page-number" href="/bjb/page/49/">49</a><span class="space">&hellip;</span><a class="page-number" href="/bjb/page/77/">77</a><a class="extend next" rel="next" href="/bjb/page/48/">下一页&raquo;</a>
  </nav>

    </main>
    <footer>
  <p>&copy; 2019 xcp0326</p>
</footer>
  </body>
</html>
