<!Doctype html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <title>FE 笔记本 🚀</title>
  
    <link rel="icon" href="/images/favico.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/bjb/style/gitalk.css">
  <link rel="stylesheet" href="/bjb/style/style.css">
  <script src="/bjb/js/gitalk.min.js"></script>
</head>
  <body>
    <header class="header">
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/bjb/" class="menu-item-link">首页</a>
        </li>
      
        <li class="menu-item">
          <a href="/bjb/archives" class="menu-item-link">归档</a>
        </li>
      
    </ul>
  </nav>
  <h1 class="pc">FE 笔记本 🚀</h1>
  <h1 class="mobile"><a href="/">FE 笔记本 🚀</a></h1>
  <em>「 学海无涯，没空撩妹！」</em>
</header>
    <main class="main">
      
  <article class="post">
  <div class="post-title">
    <h2 class="title">其他常见事件</h2>
  </div>
  <div class="post-meta">
    <span class="post-time">2019-02-26 16:07:47</span>
    <span class="post-tags">
      
    </span>
    
  </div>
  <div class="post-content">
    <blockquote>
<p><sup>这里是我读<a href="https://wangdoc.com/javascript/" target="_blank" rel="noopener">《阮一峰 JavaScript 教程》</a>做的笔记。</sup></p>
</blockquote>
<h3 id="资源事件"><a href="#资源事件" class="headerlink" title="资源事件"></a>资源事件</h3><h4 id="beforeunload-事件"><a href="#beforeunload-事件" class="headerlink" title="beforeunload 事件"></a>beforeunload 事件</h4><p>beforeunload 事件在窗口、文档、各种资源将要卸载前触发。它可以防止用户不小心卸载资源。</p>
<p>如果该事件对象的 returnValue 属性是一个非空字符串，那么浏览器就会弹车一个对话框，询问用户是否要卸载该资源。但是，用户指定的字符串可能无法显示，浏览器会展示预定义的字符串。如果用户点击“取消”按钮，资源就不会卸载。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'beforeunload'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> confirmationMessage = <span class="string">'确定关闭窗口'</span>;</span><br><span class="line">  event.returnValue = confirmationMessage;</span><br><span class="line">  <span class="keyword">return</span> confirmationMessage;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>各浏览器不一样，许多浏览器会忽略这个事件，一旦调用了这个事件，浏览器就不会缓存当前网页。因为执行了这个事件后，缓存页面就没有意义了。</p>
<p>基本上，只有一种场合可以监听 unload 事件，其他情况都不应该监听：用户修改了表单，还没有保存就要离开。</p>
<h4 id="unload-事件"><a href="#unload-事件" class="headerlink" title="unload 事件"></a>unload 事件</h4><p>unload 事件在窗口关闭或者 document 对象将要卸载时触发。它的触发顺序排在 beforeunload、pagehide 事件后面。</p>
<p>unload 事件发生时，文档处于一个特殊状态。所有资源依然存在，但是对用户来说不可见，UI 互动全部无效。这个事件是无法取消的，即使在监听函数里面抛出错误，也不能停止文档的卸载。</p>
<p>手机上，浏览器或系统可能会直接丢弃网页，这时该事件根本不会发生。而且 beforeunload 事件一样，一旦使用了 unload 事件，浏览器就不会缓存网页，因为执行了这个事件后，缓存页面就已经没有意义了。因此，任何情况下都不应该依赖这个事件，指定网页卸载时要执行的代码，可以考虑完全不使用这个事件。</p>
<h4 id="load-事件、error-事件"><a href="#load-事件、error-事件" class="headerlink" title="load 事件、error 事件"></a>load 事件、error 事件</h4><p>load 事件在页面或某个资源加载成功时触发。注意，页面或资源从浏览器缓存加载，并不会触发 load 事件。</p>
<p>error 事件是在页面或者资源加载失败时触发。abort 事件在用户取消加载时触发。</p>
<p>这三个事件实际上属于进度事件，不仅发生在 document 对象，还发生在各种外部资源上面。浏览网页就是一个加载各种资源的过程，图片、样式表、脚本、视频、音频、AJAX 请求（XMLHttpRequest）等等。这些资源和 document 对象、window 对象、XMLHttpRquestUpload 对象，都会触发 load 事件和 error 事件。</p>
<h2 id="session-历史事件"><a href="#session-历史事件" class="headerlink" title="session 历史事件"></a>session 历史事件</h2><h4 id="pageshow-事件、pagehide-事件"><a href="#pageshow-事件、pagehide-事件" class="headerlink" title="pageshow 事件、pagehide 事件"></a>pageshow 事件、pagehide 事件</h4><p>默认情况下，浏览器会在当前会话（session）缓存页面，当用户点击“前进 / 后退”按钮时，浏览器就会从缓存中加载页面。</p>
<p>pageshow 事件在页面加载时触发，包括第一次加载和从缓存加载两种情况。如果要指定页面每次加载（不管是不是从浏览器缓存）时都运行的代码，可以放在这个事件的监听函数。</p>
<p>第一次加载时，它的触发顺序排在 load 事件后面。从缓存加载时，load 事件不会触发，因为网页在缓存中加载页面的样子通常是 load 事件的监听函数运行后的样子，所以不必重复执行。同理，如果是从缓存中加载页面，网页内初始化的 JavaScript 脚本（比如 DOMContentLoaded 事件的监听函数）也不会执行。</p>
<p>pageshow 事件有一个 persisted 属性，返回一个布尔值。页面第一次加载时，这个属性时 false，当页面从缓存中加载时，这个属性时 true。</p>
<p>pagehide 和 pageshow 类似，当用户通过“前进 / 后退”按钮，离开当前页面的时候触发。它与 unload 事件的区别在于，如果在 window 对象上定义 unload 事件的监听函数之后，页面不会保存在缓存中，而使用 pagehide 事件，页面会保存在缓存中。</p>
<p>pagehide 事件实例也有一个 persisted 属性，将这个属性设置为 true，就表示页面要保存在缓存中；设为 false，就是表示网页不保存在缓存中，这时如果设置了 unload 事件的监听函数，该函数将 pagehide 事件后立即运行。</p>
<p>如果页面包含 <code>&lt;frame&gt;</code> 或 <code>&lt;iframe&gt;</code> 元素，则 <code>&lt;frame&gt;</code> 页面的 pageshow 和 pagehide 事件，都会在主页面之前触发。</p>
<p>注意，这两个事件只在浏览器的 history 对象发生变化时触发，跟网页是否可见没有关系。</p>
<h4 id="popstate-事件"><a href="#popstate-事件" class="headerlink" title="popstate 事件"></a>popstate 事件</h4><p>popstate 事件在浏览器的 history 对象的当前记录发生显式切换时触发。注意，调用 history.pushState() 或 history.replaceState() ，并不会触发 popstate 事件。该事件只在用户 histroy 记录之间切换时触发，比如 鼠标点击“后退 / 前进”按钮，或者在脚本中调用 history.back()、history.forward()、history.go() 时触发。</p>
<p>该事件对象有一个 state 属性，保存了 history.pushState 方法和 history.replaceState 方法为当前记录添加的 state 对象。</p>
<p>浏览器对于页面首次加载，是否触发 popstate 事件，处理不一样，Firefox 不触发该事件。</p>
<h4 id="hashchange-事件"><a href="#hashchange-事件" class="headerlink" title="hashchange 事件"></a>hashchange 事件</h4><p>hashchange 事件在 URL 的 hash 部分（即 # 号后面的部分，包括 # 部分）发生变化时触发。该事件一般在 window 对象上监听。</p>
<p>hashchange 事件实例有两个属性：oldURL 和 newURL，分别表示变化前后的 URL。</p>
<h3 id="网页状态事件"><a href="#网页状态事件" class="headerlink" title="网页状态事件"></a>网页状态事件</h3><h4 id="DOMContentLoaded-事件"><a href="#DOMContentLoaded-事件" class="headerlink" title="DOMContentLoaded 事件"></a>DOMContentLoaded 事件</h4><p>网页下载并解析完成后，浏览器就会在 document 对象上触发 DOMContentLoaded 事件。这时仅仅完成了网页的解析（整张页面的 DOM 生成了），所有外部资源（样式表、脚本、iframe 等）可能还么有下载结束。也就是说，这个事件比 load 事件，发生时间早得多。</p>
<h4 id="readystatechange-事件"><a href="#readystatechange-事件" class="headerlink" title="readystatechange 事件"></a>readystatechange 事件</h4><p>当 Document 对象和 XMLHrrpRequest 对象的 readyState 属性发生变化时触发。document.readyState 有是三个可能的值：loading 网页正在加载、interactive 网页已经解析完成，但是外部资源仍然处在加载状态、complete 网页和所有外部资源都已经加载结束，load 事件即将触发。</p>
<h3 id="窗口事件"><a href="#窗口事件" class="headerlink" title="窗口事件"></a>窗口事件</h3><h4 id="scroll-事件"><a href="#scroll-事件" class="headerlink" title="scroll 事件"></a>scroll 事件</h4><p>scroll 事件在文档或文档元素滚动时触发，主要出现在用户拖动滚动条时。该事件会连续地大量触发，所以它的监听函数之中不应该有非常耗费计算的操作。推荐的做法是使用 requestAnimationFrame 或 setTimeout 控制该事件的触发频率，然后可以结合 customEvent 抛出一个新事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">type, name, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = obj || <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">var</span> running = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (running) <span class="keyword">return</span>;</span><br><span class="line">      running = <span class="literal">true</span>;</span><br><span class="line">      requestAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        obj.dispatchEvent(<span class="keyword">new</span> CustomEvent(name));</span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.addEventListener(type, func);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 scroll 事件重定义为 optimizedScroll 事件</span></span><br><span class="line">  throttle(<span class="string">'scroll'</span>, <span class="string">'optimizedScroll'</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'optimizedScroll'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Resource conscious scroll callback!'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>每次页面重绘（每秒 60 次），只会触发一次 scroll 事件的监听函数。改用 setTimeout 方法，可以放置更大的时间间隔：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, scrollThrottler, <span class="literal">false</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> scrollTimeout;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">scrollThrottler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!scrollTimeout) &#123;</span><br><span class="line">      scrollTimeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        scrollTimeout = <span class="literal">null</span>;</span><br><span class="line">        actualScrollHandler();</span><br><span class="line">      &#125;, <span class="number">66</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">actualScrollHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>每 66 毫秒（每秒 15 次）执行一次 actualScrollHandler</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> time = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((time + wait - <span class="built_in">Date</span>.now()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      fn();</span><br><span class="line">      time = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, throttle(callback, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>
<p>每秒执行一次 fn 函数</p>
<h5 id="debounce-与-throttle"><a href="#debounce-与-throttle" class="headerlink" title="debounce 与 throttle"></a>debounce 与 throttle</h5><p>throttle 是节流，确保一段时间内只执行一次，而 debounce 是防抖，要连续操作结束后再执行。以网页滚动为例，debounce 要等到用户停止滚动后才执行，throttle 则是如果用户一直在滚动页面，那么在滚动过程中还是会执行。</p>
<h4 id="resize-事件"><a href="#resize-事件" class="headerlink" title="resize 事件"></a>resize 事件</h4><p>改变浏览器窗口大小的时候触发，该事件也会连续大量触发，最好也用 throttle 函数控制触发频率。</p>
<h4 id="fullscreenchange-事件、fullscreenerror-事件"><a href="#fullscreenchange-事件、fullscreenerror-事件" class="headerlink" title="fullscreenchange 事件、fullscreenerror 事件"></a>fullscreenchange 事件、fullscreenerror 事件</h4><p>进入全屏或者退出全屏状态时触发，该事件发生在 document 对象上。如果浏览器无法切换到全屏状态时触发 fullscreenerror 事件。</p>
<h3 id="剪贴板事件"><a href="#剪贴板事件" class="headerlink" title="剪贴板事件"></a>剪贴板事件</h3><ul>
<li>cut：将选中的内容从文档中移除，加入剪贴版时触发</li>
<li>copy：进行复制动作时触发</li>
<li>paste：剪贴板内容粘贴到文档后触发</li>
</ul>
<p>这三个事件都是 ClipboardEvent 接口的实例。ClipboardEvent 有一个实例属性 clipboardData，是一个 DataTransfer 对象，存放剪贴的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'copy'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.clipboardData.setData(<span class="string">'text/plain'</span>, <span class="string">'Hello world!'</span>)</span><br><span class="line">  e.clipboradData.setData(<span class="string">'text/html'</span>, <span class="string">'&lt;b&gt;Hello world!&lt;/b&gt;'</span>)</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h3><ul>
<li>focus：元素节点获得焦点后触发，该事件不会冒泡</li>
<li>blur：元素节点失去焦点后触发，该事件不会冒泡</li>
<li>focusin：获得焦点时触发，发生在 focus 事件之前，会冒泡</li>
<li>focusout：失去焦点时触发，发生在 blur 事件之前，会冒泡</li>
</ul>
<p>都继承了 FocusEvent 接口。FocusEvent 实例具有以下属性：</p>
<ul>
<li>FocusEvent.target：事件的目标节点</li>
<li>FocusEvent.relatedTarget：对于 focusin 事件，返回失去焦点的节点；对于 focusout 事件，返回将要接受焦点的节点；对于 focus 和 blur 事件，返回 null。</li>
</ul>
<p>由于 focus 和 blur 事件不会冒泡，只能在捕获阶段触发，所有 addEventListener 方法的第三个参数需要设为 true。</p>
<h3 id="CustomEvent-接口"><a href="#CustomEvent-接口" class="headerlink" title="CustomEvent 接口"></a>CustomEvent 接口</h3><p>用与生产自定义的事件实例。那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。</p>
<p>浏览器原生提供 CustomEvent() 构造函数，用来生成 CustomEvent 事件实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> evt = <span class="keyword">new</span> CustomEvent(type, options)</span><br></pre></td></tr></table></figure>
<p>CustomEvent() 构造函数接受两个参数。第一个参数是字符串，表示事件的名字，必填。第二个参数是事件的配置对象，可选的。CustomEvent 的配置对象除了接受 Event 对象的配置属性，只有一个自己的属性。</p>
<ul>
<li>detail：表示事件的附带数据，默认为 null</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> CustomEvent(<span class="string">'myevent'</span>, &#123;</span><br><span class="line">  detail: &#123;</span><br><span class="line">    foo: <span class="string">'bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  bubbles: <span class="literal">true</span>,</span><br><span class="line">  cancelable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.addEventListener(<span class="string">'myevent'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + event.detail.foo);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure>

  </div>
  
</article>


  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/bjb/page/18/">&laquo;上一页</a><a class="page-number" href="/bjb/">1</a><span class="space">&hellip;</span><a class="page-number" href="/bjb/page/17/">17</a><a class="page-number" href="/bjb/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/bjb/page/20/">20</a><a class="page-number" href="/bjb/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/bjb/page/114/">114</a><a class="extend next" rel="next" href="/bjb/page/20/">下一页&raquo;</a>
  </nav>

    </main>
    <footer>
  <p>&copy; 2019 bjb.dsphoebe.com <wbr> <a href="http://www.miitbeian.gov.cn/">京ICP备15048606号-1</a></p>
</footer>
  </body>
</html>
