<!Doctype html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <title>FE 笔记本 🚀</title>
  
    <link rel="icon" href="/images/favico.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/bjb/style/gitalk.css">
  <link rel="stylesheet" href="/bjb/style/style.css">
  <script src="/bjb/js/gitalk.min.js"></script>
</head>
  <body>
    <header class="header">
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/bjb/" class="menu-item-link">首页</a>
        </li>
      
        <li class="menu-item">
          <a href="/bjb/archives" class="menu-item-link">归档</a>
        </li>
      
    </ul>
  </nav>
  <h1 class="pc">FE 笔记本 🚀</h1>
  <h1 class="mobile"><a href="/">FE 笔记本 🚀</a></h1>
  <em>「 学海无涯，没空撩妹！」</em>
</header>
    <main class="main">
      
  <article class="post">
  <div class="post-title">
    <h2 class="title">this 关键字</h2>
  </div>
  <div class="post-meta">
    <span class="post-time">2019-03-04 12:44:24</span>
    <span class="post-tags">
      
    </span>
    
  </div>
  <div class="post-content">
    <blockquote>
<p><sup>这里是我读<a href="https://wangdoc.com/javascript/" target="_blank" rel="noopener">《阮一峰 JavaScript 教程》</a>做的笔记。</sup></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  describe: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'姓名：'</span> + <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.describe(); <span class="comment">// "姓名：张三"</span></span><br></pre></td></tr></table></figure>
<p>this.name 是在 describe 中调用，而 describe 方法所在的当前对象是 person，因此 this.name 就是 person.name。</p>
<p>对象的属性是可以赋值给其他对象的，所以属性所在的当前对象是可变的，即 this 的指向是可变的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  describe: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'姓名：'</span>+ <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">  name: <span class="string">'李四'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B.describe = A.describe;</span><br><span class="line">B.describe()</span><br><span class="line"><span class="comment">// "姓名：李四"</span></span><br></pre></td></tr></table></figure>
<p>A.describe 属性被赋值给了 B，于是 B.describe 就表示 describe 方法所在的当前对象 B，所有 this.name 指向的是 B.name</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'姓名：'</span>+ <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  describe: f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">  name: <span class="string">'李四'</span>,</span><br><span class="line">  describe: f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A.describe() <span class="comment">// "姓名：张三"</span></span><br><span class="line">B.describe() <span class="comment">// "姓名：李四"</span></span><br></pre></td></tr></table></figure>
<p>只要函数赋值给另外一个变量，this 的指向就会被改变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  describe: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'姓名：'</span>+ <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'李四'</span>;</span><br><span class="line"><span class="keyword">var</span> f = A.describe;</span><br><span class="line">f() <span class="comment">// "姓名：李四"</span></span><br></pre></td></tr></table></figure>
<h3 id="为何会存在-this"><a href="#为何会存在-this" class="headerlink" title="为何会存在 this"></a>为何会存在 this</h3><p>JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码将一个对象赋值给变量 obj。JavaScript 引擎会先在内存里面，生成一个对象 <code>{foo:5}</code> ，然后把这个对象的内存地址赋值给 obj。也就是说，变量 obj 是一个地址，一个引用。后面如果要读取 <code>obj.foo</code>，引擎先从 obj 拿到 内存地址，然后再从该地址读出原始的对象，返回它的 foo 属性。</p>
<p>原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的 foo 属性，实际上是一下面的形式保存：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: <span class="number">5</span>,</span><br><span class="line">    [[writable]]: <span class="literal">true</span>,</span><br><span class="line">    [[enumberable]]: <span class="literal">true</span>,</span><br><span class="line">    [[configurable]]: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>foo 属性的值保存在属性描述对象的 value 属性里面。</p>
<p>如果属性的值是一个函数了？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>这时，引擎会将函数单独保存在内存中，然后将函数的内存地址赋值给 foo 属性的 value 属性。</p>
<p>函数可以在不同的运行环境中执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境 context。所以 this 就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  f: f,</span><br><span class="line">  x: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br><span class="line">obj.f() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>🤔 那和 python 的 self 一样吗？ <a href="https://docs.python.org/3/tutorial/classes.html" target="_blank" rel="noopener">Classes</a><br>self 出现在 class 中。一般 class 所有的实例方法的第一个参数都命名为 self，并指向实例化后 class 的实例。</p>
</blockquote>
<h3 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h3><ol>
<li><p>指代全局环境</p>
</li>
<li><p>构造函数内部，指代实例化的对象</p>
</li>
<li><p>对象的方法内的 this 指代这个对象<br>但是，下面几种用法，会改变 this 的指向：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(obj.foo = obj.foo)() <span class="comment">// window</span></span><br><span class="line">(<span class="literal">false</span> || obj.foo)() <span class="comment">// window</span></span><br><span class="line">(<span class="number">1</span>, obj.foo)() <span class="comment">// window</span></span><br></pre></td></tr></table></figure>
<p>obj.foo 就是一个值。这个值真正调用的时候，运行环境已经不是 obj 了，而是全局环境，所以 this 不再指向 obj。</p>
<p>可以这样理解，JavaScript 引擎内部，obj 和 obj.foo 储存在两个内存地址，称为地址一和地址而。<code>obj.foo()</code> 这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，this 指向 obj。但是，上面三种情况，都是直接去除地址二进行调用，这样的话，运行环境就是全局环境，因此 this 指向全局环境。</p>
</li>
</ol>
<p>严格模式下，修改对象的方法内的 this 指向，会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> couner = &#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">counter.inc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="keyword">this</span>.count++</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = counter.inc;</span><br><span class="line">f();</span><br><span class="line"><span class="comment">// TypeError: Cannot read property 'count' of undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="绑定-this-的方法"><a href="#绑定-this-的方法" class="headerlink" title="绑定 this 的方法"></a>绑定 this 的方法</h3><h4 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func.call(thisValue, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<p>call 方法的一个应用是调用对象的原生方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.hasOwnProperty(<span class="string">'toString'</span>); </span><br><span class="line">obj.hasOwnProperty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">obj.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, <span class="string">'toString'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func.apply(thisValue, [arg1, arg2, ...])</span><br></pre></td></tr></table></figure>
<p>call 方法中原函数的参数需要一个一个添加，apply 中类数组形式传入。</p>
<h5 id="找出数组中最大的元素"><a href="#找出数组中最大的元素" class="headerlink" title="找出数组中最大的元素"></a>找出数组中最大的元素</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>, <span class="number">2</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">9</span>]</span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, a) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<h5 id="将数组的空元素变为-undefined"><a href="#将数组的空元素变为-undefined" class="headerlink" title="将数组的空元素变为 undefined"></a>将数组的空元素变为 undefined</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.apply(<span class="literal">null</span>, [<span class="string">'a'</span>,,<span class="string">'b'</span>]) <span class="comment">// ['a', undefined, 'b']</span></span><br></pre></td></tr></table></figure>
<p>原理是，在 apply 的第二个参数接受的是一个类数组对象，调用的是内置方法 CreateListFromArrayLike 方法 <code>CreateListFromArrayLike(obj[, elementTypes])</code> 如果没有定义 elementTypes 时，会被认定为 Undefined、Null、Boolean、String、Symbol、Number、Object。在生成 list 时，调用 <code>Get(obj, indexName)</code>。我们这个例子返回的是 elementTypes 里面的 undefined 了。<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-createlistfromarraylike" target="_blank" rel="noopener">CreateListFromArrayLike</a><br>然后 空元素与 undefined 差别是，数组的 forEach 方法会跳过空元素，但是不会跳过 undefined。</p>
<h5 id="转换类似数组的对象"><a href="#转换类似数组的对象" class="headerlink" title="转换类似数组的对象"></a>转换类似数组的对象</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="attr">length</span>: <span class="number">1</span>&#125;) <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="number">0</span>: <span class="number">1</span>&#125;) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;) <span class="comment">// [1, undefined]</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="attr">length</span>: <span class="number">1</span>&#125;) <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure>
<h5 id="绑定回调函数的对象"><a href="#绑定回调函数的对象" class="headerlink" title="绑定回调函数的对象"></a>绑定回调函数的对象</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">o.f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  o.f.apply(o);</span><br><span class="line">  <span class="comment">// 或者 o.f.call(o);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery 的写法</span></span><br><span class="line">$(<span class="string">'#button'</span>).on(<span class="string">'click'</span>, f);</span><br></pre></td></tr></table></figure>
<p>点击按钮以后，控制台会显示为 true。由于 apply 方法（或者 call 方法）不仅绑定函数执行时所在对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内，更简洁的写法是采用下面介绍的 bind 方法。</p>
<h4 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">d.getTime()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> print = d.getTime()</span><br><span class="line">print() <span class="comment">// Error....</span></span><br></pre></td></tr></table></figure>
<p>改用 bind 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> print = d.getTime.bind(d)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * <span class="keyword">this</span>.m + y * <span class="keyword">this</span>.n</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  m: <span class="number">2</span>,</span><br><span class="line">  n: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> newAdd = add.bind(obj, <span class="number">5</span>)</span><br><span class="line">newAdd(<span class="number">5</span>) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，bind 方法除了绑定 this 对象，还将 add 函数的第一个参数 x 绑定成 5，然后返回一个新函数 newAdd，这个函数只要再接受一个参数 y 就能运行了。</p>
<p>如果 bind 方法的第一个参数是 null 或 undefined，等于将 this 绑定到全局对象，函数运行时 this 指向顶层对象（浏览器为 window）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> plus5 = add.bind(<span class="literal">null</span>, <span class="number">5</span>)</span><br><span class="line">plus5(<span class="number">10</span>) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>bind 方法每次返回一个新函数，所以在每次添加监听函数的时候，需要赋值给一个变量，好在接下来的时候取消监听。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> listener = o.m.bind(o)</span><br><span class="line">element.addEventListener(<span class="string">'click'</span>, listener)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">element.removeEventListener(<span class="string">'click'</span>, listener)</span><br></pre></td></tr></table></figure>
<p>回调函数中使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  times: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  print: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.times.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.print()</span><br><span class="line"><span class="comment">// 没有任何输出</span></span><br><span class="line">obj.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.times.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.print()</span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 张三</span></span><br></pre></td></tr></table></figure>
<p>与 call 一起使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Function</span>.prototype.call.bind(</span><br><span class="line">  <span class="built_in">Array</span>.prototype.slice);</span><br><span class="line">slice([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>
<p>上面代码的含义就是，将 Array.prototype.slice 变成 Function.prototype.call 方法所在的对象，调用时就变成了 Array.prototype.slice.call。类似的写法还可用于其他数组方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> push = <span class="built_in">Function</span>.prototype.call.bind(</span><br><span class="line">  <span class="built_in">Array</span>.prototype.push);</span><br><span class="line"><span class="keyword">var</span> pop = <span class="built_in">Function</span>.prototype.call.bind(</span><br><span class="line">  <span class="built_in">Array</span>.prototype.pop);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span> ,<span class="number">2</span> ,<span class="number">3</span>];</span><br><span class="line">push(a, <span class="number">4</span>)</span><br><span class="line">a <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">pop(a)</span><br><span class="line">a <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>如果再进一步，将 Function.prototype.call 方法绑定到 Function.prototype.bind 对象，就意味着 bind 的调用形式也可以被改写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">v</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> bind = <span class="built_in">Function</span>.prototype.call.bind(</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind);</span><br><span class="line">bind(f, o)() <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

  </div>
  
</article>


  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/bjb/page/16/">&laquo;上一页</a><a class="page-number" href="/bjb/">1</a><span class="space">&hellip;</span><a class="page-number" href="/bjb/page/15/">15</a><a class="page-number" href="/bjb/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/bjb/page/18/">18</a><a class="page-number" href="/bjb/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/bjb/page/70/">70</a><a class="extend next" rel="next" href="/bjb/page/18/">下一页&raquo;</a>
  </nav>

    </main>
    <footer>
  <p>&copy; 2019 xcp0326</p>
</footer>
  </body>
</html>
