---
title: 二进制位运算符
category:
date: 2018-11-22 17:04:40
---

> <sup>这里是我读[《阮一峰 JavaScript 教程》](https://wangdoc.com/javascript/)做的笔记。</sup>

二进制位运算符是直接对二进制位进行运算的，效率上比其他运算符要快，二进制位运算符有 7 个：

- 二进制或运算符 or：符号为 |，两个二进制位都是 0 时，结果为 0，否则为 1
- 二进制与运算符 and：符号为 &，两个二进制位都是 1 时，结果为 1，否则为 0
- 二进制否运算符 not：符号为 ~，表示对一个二进制位取反
- 异或运算符 xor：符号为 ^，两个二进制为不相同时，结果为 1，否则为 0
- 左移运算符 left shift：<<
- 右移运算符 right shift：>>
- 头部补零的右移运算符 zero filled right shift：>>>

位运算只对整数起作用，如果一个运算子不是整数，会自从转为整数再执行运算。虽然 JavaScript 内部数值都是以 64 位浮点数的形式存储的，但是做位运算时，是以 32 位带符号的整数进行运算的，并且返回值也是一个 32 位带符号的整数。

所以，将任意数转为 32 位整数

```js
function toInt32(x) {
  return x | 0
}
```

对于一般的整数，返回值不会有任何变化，但对于大于或者等于 2<sup>32</sup> 的整数，大于 32 位的数位都会被舍去

```js
toInt32(1.0001) // 1
toInt32(1.9) // 1
toInt32(1) // 1

toInt32(2 ** 32 + 1) // 1
// 2 ** 32 + 1 --> 二进制结果为 100000000000000000000000000000001 --> 一共有 33 位，舍去第 33 位的 1，结果为 00000000000000000000000000000001 --> 转换为十进制为结果为 1

toInt32(2 ** 32) // 0
// 2 ** 32 --> 二进制结果为 100000000000000000000000000000000 --> 一共有 33 位，舍去第 33 位的 1，结果为 00000000000000000000000000000000 --> 转换为十进制为结果为 0

toInt32(2 ** 32 - 1) // -1
// 2 ** 32 - 1 --> 二进制结果为 11111111111111111111111111111111 --> 转换为十进制为 -1
```

## 二进制或运算符 |

两个二进制位之中只要有一个为 1，就返回 1，否则返回 0

位运算只对整数有效，遇到小数会舍去小数部分。小数与 0 进行二进制或运算，等同于给小数取整，这种取整方法不能超过 32 位整数最大值 2<sup>31</sup> - 1 （2147483647）的数，不能小于 -2<sup>31</sup> - 1（-2147483648）

> 🤔 32 位整数的最大值与最小值
>
> 因为位运算是有符号的 32 位整数，最高位为符号位，不参与运算，正数是 0 000 0000 0000 0000 0000 0000 0000 0000 0000 0000 到 0 111 1111 1111 1111 1111 1111 1111 1111 就是 0 到 2147483647，负数是从 1 000 0000 0000 0000 0000 0000 0000 0000 0000 0001 到 1 111 1111 1111 1111 1111 1111 1111 1111 为负 1 到负 2147483647，中间还有一个 1 000 0000 0000 0000 0000 0000 0000 0000 0000 0000 表示为负零，但是负零和正零都表示零，重复了。所以计算机规定把 1 000 0000 0000 0000 0000 0000 0000 0000 0000 0000 表示 -2147483648
>
> 所以或运算的最大值为 2147483647，最小值为 -2147483648
>
> PS 快捷方法是：最大值 `~(1 << 31)`，最小值 `1 << 31`

```js
2147483647 | 0 // 2147483647
2147483649.4 | 0 // -2147483647
2147483648 | 0 // -2147483648
-2147483648 | 0 // -2147483648
-2147483649 | 0 // 2147483647
```

## 二进制与运算 &

二进制位与运算，两个二进制位两个都为 1 时返回 1 其他返回 0

```js
0 & 3 // 0
// 00 & 11 
// 结果是 0
```

## 二进制否运算 ~

一元运算，将每一个二进制位取反（0 变成 1， 1 变成 0）。它的返回结果有时候比较难理解，因为涉及到计算机内部的数值表示机制。

```js
～3 // -4
```

上面的表达式对 3 进行二进制否运算，得到 -4。之所以会有这样的结果，是因为位运算时，JavaScript 内部将所有的运算子都转为 32 位的二进制整数再进行运算。

3 的 32 位整数形式时 0000 0000 0000 0000 0000 0000 0000 0011，二进制否运算以后得到 1111 1111 1111 1111 1111 1111 1111 1100。第一位是符号位 1，所以这个数是个负数。JavaScript 内部菜用补码形式表示负数，即需要将这个数减 1，再取反，然后再加上负号，才能得到这个负数对应的十进制值。

1111 1111 1111 1111 1111 1111 1111 1100 减 1 
--> 1111 1111 1111 1111 1111 1111 1011 取反 
--> 0000 0000 0000 0000 0000 0000 0000 0100 转成 十进制
--> 加负号 -4

过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加等于 -1

```js 
～-2 // 1
～5 // -6
```

对一个整数连续两次进行二进制否运算，得到它自身。

```js
~~3 // 3
```

所有位运算都只对整数有效。二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以对一个小数连续进行两次二进制否运算，能达到取整的效果。

```js
~~3.2 // 3
```

二进制否运算取整，是所有取整方法中最快的一种。🤔比二进制或运算要快？

对字符串进行二进制否运算，JavaScript 引擎会先调用 Number 函数，将字符串转为数值

```js
~'011' // -12
~'42 cat' // -1
~'0xcafebabe' // 889275713 🤔
~'deadbeef' // -1
```

对其他类型的值，二进制否运算也是先进行 Number 转为数值，然后再进行处理。

## 异或运算符

两个二进制位不同时返回 1，相同时返回 0

```js
0 ^ 3 // 3
```

异或运算可以实现不引入临时变量的前提下将两个数值互换。连续对两个数值 a 和 b 进行三次异或运算，a^=b; b^=a;a^=b;，可以互换他们的值。

> 🤔 异或运算两值互换
>
> ```js
> a ^= b // na = a^b
> b ^= a // nb = b^na --> nb = b^a^b --> nb = b^b^a --> nb = 0^a --> nb = a
> a ^=b // a = na^nb --> a = a^b^b^a^b --> na = b
> ```

异或也可以用来取整

```js
12.9^0 //12
```

## 左移运算符

左移运算符 << 表示将一个数的二进制值向左移动指定的位数，尾部补 0，即乘以 2 的指定次方。向左移动的时候，最高位的符号位是一起移动的。

```js
// 4 的二进制形式为 100
// 左移一位为 1000 即 十进制的 8
// 相当于乘以 2 的 1 次方
4 << 1 // 8
-4 << 1 // -8
```

-4 左移一位得到 -8，是因为 -4 的二进制形式是 1111 1111 1111 1111 1111 1111 1111 1100，左移一位后得到 1111 1111 1111 1111 1111 1111 1111 1000，该数为十进制 -8

左移运算符用于二进制数值非常方便，RGB 颜色转换为十六进制的颜色：

```js
var color = {
  r: 186,
  g: 218,
  b: 85
}
// RGB to HEX
// 1 << 24 作用为保证结果是 6 位数
var rgb2hex = function(r,g,b) {
  return '#' + ((1<<24) + (r<<16)+(g<<8) + b)
  	.toString(16) // 先转成十六进制，然后返回字符串
  	.substr(1) // 去除字符串的最高位，返回后面的六个字符
}
rgb2hex(color.r, color.g, color.b)
// "#bada55"
```

## 右移运算符

右移运算符表示将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补`0`；如果是负数，头部全部补`1`。右移运算符基本上相当于除以`2`的指定次方（最高位即符号位参与移动）。

```js
4 >> 1 // 2
-4 >> 1 // -2
// 因为 -4 的二进制形式是 1111 1111 1111 1111 1111 1111 1111 1100
// 右移一位，头部补 1， 得到 1111 1111 1111 1111 1111 1111 1111 1110
// 即为十进制的 -2
```

右移运算可以模拟 2 的整除运算

```js
5 >> 1
// 2
// 相当于 5 / 2 = 2

21 >> 2
// 5
// 相当于 21 / 4 = 5
```

## 头部补零的右移运算符

与右移运算符（`>>`）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补零，而不考虑符号位。所以运算总是得到正数。对于正数，该运算的结果于右移运算 >> 完全一致。

```js
4 >> 1 // 2
4 >>> 1 // 2

-4 >> 1 // -2
-4 >>> 1 // 2147483646
```

这个运算实际上是将一个值转为 32 位无符号整数

可以用来查看一个负整数在计算机内部的存储形式

```js
-1 >>> 0 // 4294967295
```

上面的代码表示，-1 作为 32 位整数时，内部的存储形式使用无符号整数个数解毒，值为 4294967295 （即 2<sup>32</sup> - 1)，等于 1111 1111 1111 1111 1111 1111 1111 1111。

## 开关作用

位运算可以用设置对象属性的开关

假定某个对象有 4 个开发，每个开关对应一个变量。那么可以设置一个 4 位的二进制数，它的每一位对应一个开关。

```js
var FLAG_A = 1 // 0001
var FLAG_B = 2 // 0010
var FLAG_C = 4 // 0100
var FLAG_D = 8 // 1000
```

上面代码设置 A、B、C、D 四个开关，每个开关分别占有一个二进制位。

然后，就可以用二进制与运算检验，当前设置是否打开了指定开关。

```js
var flags = 5
if (flags & FLAG_C) {
  // ...
}
// 0101 & 0100 --> 0100 => true 
```

上面代码检验是否打开了开关 C。如果打开，会返回 true，否则返回 false

现在假设需要打开 A、B、D 三个开关，我们可以构造一个掩码（掩码 bitmask是一个通过与/或来读取标志位的位序列）。

```js
var mask = FLAG_A | FLAG_B | FLAG_D
// 0001 | 0010 | 1000 => 1011
```

有了掩码，二进制或运算可以确保打开指定的开关。

```js
flags = flags | mask
// 0101 | 1011 => 1111 => 三个开关都是开的
```

二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关掉。

```js
flags = flags & mask
// 0101 & 1011 => 0001 只开开关 D
```

异或运算可以切换 toggle 当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值

```js
flags = flags ^ mask
// 0101 ^ 1011 => 1110 
// 1110 ^ 1011 => 0101
```

二进制否运算可以翻转当前设置，即原来设置为 0，运算后变为 1，原来设置为 1，运算后变为 0.

```js
flags = ~flags
```

## 位运算取整

```js
  2.3 | 0 // 2
  ~~2.3 // 2 这么看起来，连续两次二进制否运算会是最快，是一元运算
  2.3 ^ 0 // 2
  2.3 >> 0 // 2
  2.3 << 0 // 2
```
位运算只能取整 -2<sup>31</sup> - 1 到 2<sup>31</sup> - 1 之间的数

## 参考 or 深入阅读
[js中使用位操作符取整有没有什么副作用？](https://www.zhihu.com/question/50856132)